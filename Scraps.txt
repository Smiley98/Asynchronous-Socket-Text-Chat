static bool logging = false;
if (GetAsyncKeyState(VK_SPACE))
    logging = !logging;
if (logging) {
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    printf("Receiving...\n");
}

//Not the worst idea, but implementing this would mess up either back() or front(), and actually complicate to/from string. 
/*struct Metadata {
	union {
		struct {
			byte metadata[8] = { '\0' };
		};
		struct {
			byte null;
			byte type;
			byte reserved_byte_3;
			byte reserved_byte_4;
			byte reserved_byte_5;
			byte reserved_byte_6;
			byte reserved_byte_7;
			byte reserved_byte_8;
		};
	};
};*/

template<size_t count>
PacketType Packet<count>::getType()
{
#if _DEBUG
	assert(this->back() < PacketType::COUNT);
#endif
	return this->back();
}

template<size_t count>
void Packet<count>::setType(PacketType packetType)
{
#if _DEBUG
	assert(packetType < PacketType::COUNT);
#endif
	this->back() = packetType;
}

//Even this Packet structure is unnecessary! As long as we reserve element 0 for type and element 1+ for object we're set!
//struct Packet {
//	PacketType type;
//	void* data;
//};

//toPacket is literally just assign the data member.

//Even this doesn't work because shit with overriden methods isn't POD. Just memcpy actual POD structures to/from packets!
//struct Raw {
//	//Writes data to packet.
//	virtual void Serialize(char* packet) = 0;
//
//	//Reads data from packet.
//	virtual void Deserialize(const char* packet) = 0;
//};

//Use case:
//byte packet[PACKET_SIZE];
//if not socket error,
//	switch(packet[0])
//		case INPUT:
//			network.inputs.push_back(*fromPacket<Input>(packet));//Dereference to ensure a deep copy is appended.

//This class is going to be ugly to use because its templated. Casting would created redundancies and look verbose.
/*template<size_t count>
class Packet
{
public:
	Packet();
	Packet(const Packet<count>& packet);
	Packet& operator=(const Packet<count>& packet);
	void copyToPool(concurrency::concurrent_vector<Packet<count>>& packetPool);

	std::string toString();
	void fromString(const std::string& string);

	PacketType getType();
	void setType(PacketType packetType);

private:
	//POD to ensure correct memory layout for serialization/deserialization.
	//*Cannot assign values on default initialization otherwise not POD.
	//*Class types call default constructor on default initialization, fundamental types are left uninitialized (so we gotta fill on packet create).
	struct Internal {
		PacketType m_type;
		std::array<byte, count> m_binary;
	} m_internal;

	void copyFrom(const Packet& packet);
	void zeroInitialize();
};

class SmallPacket : public Packet<63> {};
class MediumPacket : public Packet<255> {};
class LargePacket : public Packet<1023> {};

typedef concurrency::concurrent_vector<SmallPacket> SmallPacketPool;
typedef concurrency::concurrent_vector<MediumPacket> MediumPacketPool;
typedef concurrency::concurrent_vector<LargePacket> LargePacketPool;

class Network
{
protected:
	void startupWSA();
	void cleanupWSA();
};

template<size_t count>
struct POD {
	//Writes data to packet.
	virtual void Serialize(Packet<count>& packet) = 0;

	//Reads data from packet.
	virtual void Deserialize(const Packet<count>& packet) = 0;
};

template<size_t count>
Packet<count>::Packet()
{
	zeroInitialize();
}

template<size_t count>
Packet<count>::Packet(const Packet<count>& packet)
{
	copyFrom(packet);
}

template<size_t count>
Packet<count>& Packet<count>::operator=(const Packet<count>& packet)
{
	copyFrom(packet);
	return *this;
}

template<size_t count>
void Packet<count>::copyToPool(concurrency::concurrent_vector<Packet<count>>& packetPool)
{
	packetPool.resize(packetPool.size() + 1);
	packetPool.back() = *this;
}

template<size_t count>
std::string Packet<count>::toString()
{
	return std::string(reinterpret_cast<const char*>(m_internal.m_binary.data()));
}

template<size_t count>
void Packet<count>::fromString(const std::string& string)
{
	assert(string.size() < count);
	string.copy(reinterpret_cast<char* const>(m_internal.m_binary.data()), string.size());
}

template<size_t count>
PacketType Packet<count>::getType()
{
	assert(m_internal.m_type < PacketType::COUNT);
	return m_internal.m_type;
}

template<size_t count>
void Packet<count>::setType(PacketType packetType)
{
	assert(packetType < PacketType::COUNT);
	m_internal.m_type = packetType;
}

template<size_t count>
inline void Packet<count>::copyFrom(const Packet<count>& packet)
{
	memcpy(&m_internal, &packet.m_internal, sizeof(Internal));
}

template<size_t count>
inline void Packet<count>::zeroInitialize()
{
	memset(&m_internal, 0, sizeof(Internal));
}

ClientState clientState = getState();
if (clientState == INITIALIZING) {
	init();
	std::thread(&run_internal, this).detach();
	setState(INITIALIZED);
	m_running = true;
}
else {
	printf("Invalid call. Client state (%c) is not INITIALIZING.\n", clientState);
}
*/

/*void Server::connect()
{
	printf("Listening. . .\n");
	m_state.store(State::CONNECT);
	while (m_state.load() == State::CONNECT) {
		SOCKADDR_IN fromAddress;
		memset(&fromAddress, 0, sizeof(fromAddress));
		int fromAddressLength = sizeof(fromAddress);

		char packet[PACKET_LENGTH];
		memset(packet, 0, PACKET_LENGTH);

		if (recvfrom(m_socket, packet, PACKET_LENGTH, 0, (SOCKADDR*)&fromAddress, &fromAddressLength) != SOCKET_ERROR) {
			//Connectivity packet to filter out unwanted trafic.
			if (strcmp(packet, "CONNECTION\n") == 0) {
				//Add the address if we have no clients, otherwise only add unique addresses (this sucks without maps).
				if (m_clientAddresses.empty()) {
					m_clientAddresses.push_back(fromAddress);
					char ipbuf[INET_ADDRSTRLEN];
					printf("%s connected.\n", inet_ntop(AF_INET, &fromAddress, ipbuf, sizeof(ipbuf)));
				}
				else {
					bool found = false;
					for (size_t i = 0; i < m_clientAddresses.size(); i++) {
						found |= compareAddresses(fromAddress, m_clientAddresses[i]);
					}
					if (!found)
					{
						m_clientAddresses.push_back(fromAddress);
						char ipbuf[INET_ADDRSTRLEN];
						printf("%s connected.\n", inet_ntop(AF_INET, &fromAddress, ipbuf, sizeof(ipbuf)));
					}
				}

				//Send connection packet back to client repeatedly in case it gets lost.
				sendto(m_socket, packet, PACKET_LENGTH, 0, (SOCKADDR*)&fromAddress, fromAddressLength);

				//Auto-start once we have 2+ clients. See commented code below for manual start implementation.
				if (m_clientAddresses.size() >= 2) {
					strcpy(packet, "START\n");
					for (size_t i = 0; i < m_clientAddresses.size(); i++) {
						sendto(m_socket, packet, PACKET_LENGTH, 0, (SOCKADDR*)&m_clientAddresses[i], fromAddressLength);
					}
					m_state = State::RUN;
					//run();
				}
				//\n is part of START because the input code appends \n.
				//if (strcmp(packet, "START\n") == 0) {
				//	//Send the message back to the clients so they know to start.
				//	for (size_t i = 0; i < m_clientAddresses.size(); i++) {
				//		sendto(m_socket, packet, PACKET_LENGTH, 0, (SOCKADDR*)&m_clientAddresses[i], fromAddressLength);
				//	}
				//	run();
				//}
			}
		}
	}
}

//1. Determine which client a message came from.
//2. Send that message to any client but the sender.
//3. Profit.
void Server::run()
{
	printf("Transmitting. . .\n");
	while (m_state == State::RUN) {
		SOCKADDR_IN fromAddress;
		memset(&fromAddress, 0, sizeof(fromAddress));
		int fromAddressLength = sizeof(fromAddress);

		char packet[PACKET_LENGTH];
		memset(packet, 0, PACKET_LENGTH);

		//Consider coming up with a condition to implicity shutdown ie m_clientAddresses.empty(); -> server broadcasts quit and shuts itself down.
		if (recvfrom(m_socket, packet, PACKET_LENGTH, 0, (SOCKADDR*)&fromAddress, &fromAddressLength) != SOCKET_ERROR) {
			if (strcmp(packet, "QUIT\n") == 0)
				shutdown();

			for (size_t i = 0; i < m_clientAddresses.size(); i++) {
				if (compareAddresses(fromAddress, m_clientAddresses[i]))
					continue;
				sendto(m_socket, packet, PACKET_LENGTH, 0, (SOCKADDR*)&m_clientAddresses[i], fromAddressLength);
			}
		}
	}
}

void Server::shutdown()
{
	char packet[PACKET_LENGTH] = "QUIT\n";
	for (size_t i = 0; i < m_clientAddresses.size(); i++) {
		sendto(m_socket, packet, PACKET_LENGTH, 0, (SOCKADDR*)&m_clientAddresses[i], sizeof(m_clientAddresses[i]));
	}
	closesocket(m_socket);
	cleanupWSA();
}

//Not sure if this is viable because more than one listener will consume packets meant for other listeners.
//If we were to make a listener exclusively for packets that wouldn't be terrible.
//We wouldn't be I/O bound regardless, but we might be able to bring clarity to our code by separating I/O from logic.
void Server::stateListener()
{
	while (true) {
		switch (m_state.load())
		{
		case CONNECT:
			break;
		case RUN:
			break;
		default:
			break;
		}
	}
}*/
